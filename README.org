#+TITLE: Travel Journal app

An app that helps you journal your travels, made for my /CS3040 Mobile Design and Development/ course at university. For the time I had, I am happy with the current implementation details of Travel Journal, which follow best practices and allow for easier simpler development in the future.

I could of hacked together functionality to meet more of the design requirements for my submission, but I don't regret learning best practices for Android development, as well as exploring advanced features—namely the heterogeneous timeline—which would be necessary for a truly unique and fun end-user experience.

* Software engineering report
  The following text is part of my development docs I made for my report. It was made using ~org-mode~, so unfortunately it breaks a bit due the restrictions of GitHub-flavoured ~.org~ markup.

** MVVM
   Travel Journal uses the Model-View-ViewModel architecture patterns, where a View drives data from a respective ViewModel, as opposed to directly from the Model. ViewModels persist with their respective View's life-cycle in the application.

   There are multiple advantages to this approach in Android app development, compared to Views directly interacting with the Model:

   1. ViewModels can persist in the life-cycle longer than a particular instance of a View, which is a necessity to keep the View's data available when a View has to be re-instantiated, like when changing to a horizontal layout when rotating the phone.

   2. It enables a separation between the View and Model, where updates to the Model don't require the View to change too. MVVM assigns the responsibility of persisting the View's data with the Model, acting as a separation of concerns so when writing View logic I can focus on the user interfacing.

   3. ViewModels allow an abstraction of Model data, which can be advantageous when desired transformations aren't directly supported by the Model itself. An example of this is in the [[*Heterogeneous Holiday Timeline]] implemented for Travel Journal.

   4. ViewModels have to aggregate the parts of the model the associated View is concerned with, rather than expose the whole model to the View. When designing the ViewModel for a View, I need to think about what is actually need to access in the Model, so as not to expose more than is required.

   #+CAPTION: A separation of each Model-View-ViewModel componenet can be seen in the codebase's folder structure..
   | Component | Primary folder |
   |-----------+----------------|
   | Model     | ~store/~       |
   | View      | ~activities/~  |
   | ViewModel | ~models/~      |

** Room library
   For Travel Journal's model, the /Room/ library is used. Room acts as an abstraction over /SQLite/ databases, representing the tables and records of a database into classes and objects. 

   Room allows for creation of Java classes known as /Entities/ to represent tables. These tables are accessed via a /Data Access Objects/ (or /Daos/), which can seamlessly input and output Entity objects. This means I don't have to serialise the records every time when querying the database, as I can simply receive record as an Entity object instead.

   The use of Java classes to define table schemas comes with the benefits of the object-orientated paradigm. In Travel Journal I utilise inheritance for some Entity classes (described further in [[*Storing feed items in Room]]), which established consistent features for a group of related tables in one parent Entity.

** Repository for the app
   A repository ~AppRepository~ is used in Travel Journal, which abstracts the interaction of the store for the rest of the application. Specifically, ViewModels do not access the app's database directly, but instantiates the repository to access and mutate the database indirectly.

   Currently the repository only interacts with the Room store of the application, but the benefit of implementing a repository is if that changes. The application only concerns itself with what it needs from /a/ store, so modifications of the store—such as migrations to different technology or integrating an  online service—only requires adjustments in the repository, rather than in all the instances where the store would be accessed directly.

** Observable data
    Instead of accessing store data directly, Android's LiveData is used as a wrapper so that Views can remain consistent with the applications state. This is achieved by the observable interfacing the ~observe()~ method provide, so I can write code that executes every time the store data changes.

    #+CAPTION: A ~LiveData~ object is observed so a ~HolidayActivity~ updates its thumbnail image when the user picks a new thumbnail.
    #+begin_src java
 ImageView thumbnail = findViewById(R.id.thumbnail);
 holidayViewModel.getThumbnail().observe(this, image -> {
     if (image != null) {
         Bitmap bitmap = BitmapFactory.decodeFile(image.getPath());
         thumbnail.setImageBitmap(bitmap);
     }
 });
    #+end_src

    Importantly, most Room Dao queries return Entities as LiveData. The Room library knows to notify changes to the LiveData object when the column(s) or record(s) accessed are mutated.

    #+CAPTION: The ~HolidayDao~ returning all holiday records as a list of ~Holiday~ entities, wrapped in a ~LiveData~ object.
    #+begin_src java
 @Query("SELECT * FROM holidays ORDER BY start_date ASC")
 LiveData<List<Holiday>> getAll();
    #+end_src

** RecyclerView adaptors
   The ~RecyclerView~ is used in Travel Journal to display listed content, due to its performance benefits over the ~ListView~.

   A base adaptor ~RecyclerView.Adaptor~ is provided  to be extended and applied to the layout's RecyclerView. Following the adaptor pattern, this enables interfacing the RecyclerView from the Activity using it. Specifically, Adaptor files are kept in a seperate folder ~adaptors/~, which is instantiated and set to the RecyclerView in the corresponding Activity.

   #+CAPTION: Adaptor use in ~HolidayListActivity.java~, where ~HolidayListAdaptor~ is defined in the ~adaptors/~ folder.
   #+begin_src java
     RecyclerView recyclerView = findViewById(R.id.recycler_view);
     final HolidaysListAdaptor adaptor = new HolidaysListAdaptor(this);
     recyclerView.setAdaptor(adaptor);
     ...
     holidaysListViewModel.getAllHolidays()
         .observe(this, adaptor::setHolidays);
   #+end_src

** ViewModel factories
   The AndroidX library's ~ViewModelProvider~ is used to instantiate life-cycle aware ViewModels, but cannot pass in arguements. This prevents creating particular instances of a ViewModel, i.e. a ViewModel that holds the model of a /particular/ holiday.

   ~ViewModelProvider.Factory~ is provided to be extended and use as a factory for the ViewModel to be of a specified purpose via arguements. The factory pattern defines an interface for creating new objects, so I can ensure my ViewModels work with carefully-crafted ViewModel systems in the library.

   #+CAPTION: ~EditHolidayActivity~ instantiating a ViewModel for the particular Holiday the Activity has been called to represent and edit.
   #+begin_src java 
     long holidayId = getIntent().getExtras()
         .getLong(HolidayActivity.EXTRA_HOLIDAY_ID);
     EditHolidayViewModelFactory editHolidayViewModelFactory =
         new EditHolidayViewModelFactory(this.getApplication(), holidayId);
     return new ViewModelProvider(this, editHolidayViewModelFactory)
         .get(EditHolidayViewModel.class);
   #+end_src

** Heterogeneous Holiday Timeline
   Travel Journal has a timeline for every holiday, where users can detail their holiday. Currently only notes and pictures can be taken (or added from storage), but implementing other kinds of media would be simple due to the heterogeneous nature of ~HolidayActivity~ and ~HolidayViewModel~.

   The adaptor used for the RecyclerView in the HolidayActivity has specific ViewHolders—classes that determine how the list item renders—which allows for a mixture of views in one single feed, i.e.  images and text.

   #+CAPTION: Notes are rendered using the ~NoteViewHolder~ whilst Images are rendered using the ~ImageViewHolder~, both defined in ~HolidayFeedAdaptor.java~.
   #+begin_src java
     private class NoteViewHolder extends HolidayFeedViewHolder {
         private TextView textView;

         NoteViewHolder(@NonNull View itemView) {
             super(itemView);
             textView = itemView.findViewById(R.id.text_view);
         }

         public void onBind(FeedItem feedItem) {
             Note note = (Note) feedItem;
             textView.setText(note.getContents());
         }
     }

     private class ImageViewHolder extends HolidayFeedViewHolder {
         private ImageView imageView;

         ImageViewHolder(@NonNull View itemView) {
             super(itemView);
             imageView = itemView.findViewById(R.id.image_view);
         }

         public void onBind(FeedItem feedItem) {
             Image image = (Image) feedItem;
             Bitmap bitmap = Rendering.getBitmap(context, image.getUri())
             imageView.setImageBitmap(bitmap);
         }
     }

   #+end_src

   The selection is achieved by determining the "item type" of each list item, where an enum has been shared amongst all timeline Entities. The appropiate layout resource's ID can be mapped to each type, and each layout can be mapped to the required ViewHolder.

   #+CAPTION: The ~getItemViewType~ method provided by ~RecyclerView.Adaptor~ can be overriden for such custom behaviour.
   #+begin_src java
 @Override
 public int getItemViewType(int position) {
     FeedItem.TYPES type = feed.get(position).getItemType();
     switch (type) {
         case NOTE:
             return R.layout.recycler_note_view;
         case IMAGE:
             return R.layout.recycler_image_view;
         default:
             throw new IllegalStateException();
     }
 }
   #+end_src

   #+CAPTION: The ~onCreateViewHolder~ method can apropiately assign the correct ViewHolder for each type of timeline item..
   #+begin_src java
     @Override
     public HolidayFeedViewHolder onCreateViewHolder(...) {
         View view = null;
         switch (viewType) {
             case R.layout.recycler_note_view:
                 view = layoutInflater.inflate(R.layout.recycler_note_view, ...);
                 return new NoteViewHolder(view);
             case R.layout.recycler_image_view:
                 view = layoutInflater.inflate(R.layout.recycler_image_view, ...);
                 return new ImageViewHolder(view);
             default:
                 throw new IllegalStateException();
         }
     }
   #+end_src

*** Storing feed items in Room
    To achieve the behaviour of finding the type of timeline item,  a parent Entity ~FeedItem~ is defined with an enum of all item types and a method to be overriden by all types of timeline items, i.e. currently ~Note~ and ~Image~.

    #+CAPTION: The ~TYPES~ enum and the ~getItemType()~ method in ~FeedItem.java~.
    #+begin_src java
 public enum TYPES {NOTE, IMAGE, PLACE}
 public TYPES getItemType() { 
     return null;
 }
    #+end_src

    #+CAPTION: In ~Note.java~, the Note entity returns it's of type ~NOTE~ in the ~getItemType()~ method.
    #+begin_src java
   @Override
   public TYPES getItemType() {
       return TYPES.NOTE;
   }
    #+end_src

    Additionally, ~FeedItem~ contains desired behaviour all timeline items should have—a many-to-one relationship with a ~Holiday~ entity.

    #+CAPTION: Children of ~FeedItem~ all have a primary key of ~item_id~ and a foreign key of ~holiday_id~, as well as a ~created_at~ timestamp.
    #+begin_src  java
   @Entity(foreignKeys = @ForeignKey(entity = Holiday.class,
           parentColumns = "holiday_id",
           childColumns = "item_id",
           onDelete = CASCADE))
   public class FeedItem {
       ...
       @NonNull
       @ColumnInfo(name = "item_id")
       private long itemId;

       @NonNull
       @ColumnInfo(name = "holiday_id")
       private long holidayId;

       @ColumnInfo(name = "created_at")
       public LocalDateTime createdAt;
       ...
   }
    #+end_src

    A benefit of the shared properties timeline items have is in the ViewModel. Whilst timeline filtering capabilities are not available at this time, abstracting all timeline items as ~FeedItem~ makes it a possibility. In ~HolidayViewModel.java~, the different timeline items can be stored heterogeneously by upcasting to ~FeedItem~.

    #+CAPTION: The ~feed~ variable stores all timeline items for a holiday, updating its contents by observing the relevant LiveData objects returned by Room Daos.
    #+begin_src java
      /* Access all related feed items */
      LiveData<List<Note>> notes = appRepository.getNotesFromHoliday(holidayId);
      LiveData<List<Image>> images = appRepository.getImagesFromHoliday(holidayId);

      /* Setup feed mediator */
      feed = new MediatorLiveData<>();
      feed.setValue(new ArrayList<>());
      // Add sources
      feed.addSource(notes, items -> updateFeed(items, FeedItem.TYPES.NOTE));
      feed.addSource(images, items -> updateFeed(items, FeedItem.TYPES.IMAGE));
    #+end_src

    #+CAPTION: ~FeedItem~ provides useful shared interfacing by way of ~getItemType()~ to update the list of timeline items in the ~updateFeed()~ method.
    #+begin_src java
      private <T extends FeedItem> void updateFeed(List<T> itemsOfType, TYPES type) {
          if (itemsOfType != null && feed.getValue() != null) {
              Stream<FeedItem> feedWithoutType = feed.getValue().stream()
                      .filter(feedItem -> feedItem.getItemType() != type);

              List<FeedItem> sortedFeed = Stream
                      .concat(feedWithoutType, itemsOfType.stream())
                      .sorted((item1, item2) -> item2.getCreatedAt()
                      .compareTo(item1.getCreatedAt()))
                      .collect(Collectors.toList());

              feed.setValue(sortedFeed);
          }
      }
    #+end_src

